## 执行上下文



**什么是执行上下文？**



分为全局执行上下文和函数执行上下文：

- 全局执行上下文只有一个，运行js程序时创建

- 每次调用函数时都会创建一个函数执行上下文。



**执行栈：**

存放执行上下文的栈结构，新创建的执行上下文入栈，执行完执行上下文中的代码后出栈。位于执行栈栈顶的执行上下文称为当前执行上下文。js只会执行当前执行上下文中的代码。

<img src="https://gitee.com/li_zihang/typora-drawing-bed/raw/master/图片/image-20210613162445803.png" alt="image-20210613162445803" style="zoom: 50%;" />

js程序在执行时会首先创建一个全局执行上下文，并压入执行栈，作为当前执行上下文开始执行其中的代码。调用函数时会创建一个函数执行上下文，并压入执行栈，成为当前执行上下文，所以开始执行函数执行上下文中的代码。执行完后该函数执行上下文出栈。全局执行上下文成为栈顶继续执行。





## 执行上下文的生命周期



1. 创建执行上下文

   - 确定this的值

   - 创建词法环境
   - 创建变量环境

2. 执行代码

3. 回收执行上下文



**确定 this的值**

全局执行上下文中 this指向全局对象，浏览器中为 window对象。

函数执行上下文中 this指向调用函数的对象。



**创建词法环境和变量环境**



词法环境：

1. 对象环境记录器
2. 外部环境的引用

变量环境：

1. 声明式环境记录器
2. 外部环境的引用



将执行上下文中**顶级的let、const、class声明**和**函数声明**去重并定义到词法环境的环境记录器，前者不会初始化。后者将整个函数定义上去。

将执行上下文中**顶级的 var声明**去重并定义到变量环境环境记录器并初始化为 undifined。

外部环境的引用：全局执行上下文中为 null，函数执行上下文中指向父执行上下文对应的词法环境。



**执行代码**



执行上下文中自顶向下执行代码，当调用变量或函数时，会到变量环境和词法环境的环境记录器中查找，找不到则根据外部环境的引用到父级执行上下文的变量环境和词法环境中查找，这样依次查找下去直到全局上下文的词法环境，找不到则报错。形成了作用域链。

当代码中的赋值语句为变量或函数重新赋值时，会改变词法环境和变量环境中对应的值，这样赋值语句代码之后访问时返回的就是新值。



**回收执行上下文**

执行上下文中的代买执行完毕后，开始回收





## 去重处理

各种声明在定义到环境记录器之前还会进行去重处理：

let、const、class声明之间重复或与函数声明、var声明重复会报错

相同名称的 var声明、函数声明添加到环境记录器中时只会添加一次。如

```js
var a = 10;
var a ;
console.log(a);  //不会报错也不会返回undifined而是返回10
```

扫描后将 a添加到变量环境的环境记录器中，并初始化为 undifined。执行代码时将 a赋值为10，则更新环境记录器中 a为10；下一行执行代码时a没有被赋值，所以打印a时返回10



```js
console.log(foo());            //函数声明
function foo(){
  return '函数声明';
}
var foo = function() {                 
  return '函数字面量';
};              
```

函数声明定义的函数与 var定义的函数重名时，函数声明优先级高，会将函数声明定义的函数定义到词法环境的环境记录器中，var声明不做处理。所以执行第一行代码时访问 foo()，去词法环境中查找到的是函数声明定义的函数，所以返回的是 ”函数声明“。

但代码执行到var声明时，会将环境记录器中的 foo()函数更新为新的函数，相当于变量的重新赋值。所以再打印 foo()，显示的就是 ”函数字面量“了。





## 提升

在上下文中执行代码之前，顶级的变量和函数声明都已经定义到变量环境和词法环境中去了。

```js
console.log(a);   //undifined
var a = 10;
console.log(a);   //10
```

在创建上下文的阶段， var a被添加到变量环境中，并初始化为 undifined，所以在定义代码之前访问不会报错而是返回 undifined，但这种现象并不符合代码的直观预期，看起来就好像

```js
var a = undifined
console.log(a);   
a = 10;
console.log(a);  
```

这种现象称为变量提升。

同样，函数声明定义的函数也是如此

```js
a();                  //1,同样也不会报错
function a() {
  return 1;
}
```

顶级 function函数声明的函数会被添加到词法环境中，使执行上下文中所有的代码都能访问到。相当于

```js
function a() {
  return 1;
}
a();                  //1,同样也不会报错
```

称为函数声明提升。



let、const、class声明只是添加到词法环境中但并未初始化

```js
console.log(a);
let a = 10;
```

在定义之前访问会报错：变量a未初始化。所以说 let、const、class定义的变量不会提升。 



暂时性死区？

变量环境和词法环境中添加的都是顶级的 let、const、class声明，var声明和函数声明，那块级作用域中的 let、const、class声明呢？