## 从输入 URL 到页面展示发生了什么？



1. 输入url
2. url由DNS服务器解析成对应的ip地址
3. 与ip地址对应的服务器经过三次握手建立TCP/IP的连接，然后发送一个 HTTP 请求
4. 服务器的永久重定向响应，服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问`http://www.google.com/`而非`http://google.com/`。
5. 浏览器跟踪重定向地址，浏览器知道了 `http://www.google.com/` 才是要访问的正确地址，所以它会发送另一个http请求。
6. 服务器处理请求，并返回一个HTTP响应
7. 浏览器解析显示 HTML



浏览器渲染过程：

浏览器内核在解析html文件时，会”自上而下“加载，并在加载过程中进行解析渲染，在解析过程中遇到CSS、图片等资源文件会发送异步请求下载对应的文件并解析成CSS rules，该过程不会影响HTML的解析；但是遇到JS会停止解析HTML，发送请求将JS下载、解析、执行完成后再继续解析HTML，最终形成DOM树。DOM树与CSS rules构建成渲染树，然后浏览器内核开始布局渲染树并将其绘制到屏幕上。

所以JS文件通常在html的末尾引用。



DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互**映射**的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。





## 浏览器内核与js引擎的关系



以 `webkit` 内核为例

```
webkit = WebCore + JavaScriptCore
```

![image-20210831102009522](https://gitee.com/li_zihang/typora-drawing-bed/raw/master/图片/image-20210831102009522.png)







## v8引擎的工作原理









## JS代码解析执行过程



涉及概念：VO、GO、AO、执行栈、全局执行上下文、函数执行上下文、作用域、作用域链、提升



**执行栈**（栈：后进先出）

js引擎解析执行js代码是通过执行栈、执行上下文完成的。

全局代码解析前执行栈中压入全局执行上下文，解析执行其中的代码，执行到调用函数时，创建一个函数执行上下文压入执行栈，函数体中的代码解析执行完毕后函数执行上下文出栈销毁，继续执行全局执行上下文中的代码。

全局、函数上下文都有创建（解析）、执行、销毁三步。



**全局执行上下文**

解析全局代码前会创建一个全局执行上下文和一个GO对象，全局上下文的VO指向GO，所有代码执行完毕后销毁全局执行上下文和GO对象

```js
EC = {
   VO                     //指向GO，在浏览器中就是window对象
   scope                  //作用域，指向VO
   this                   //指向GO，在浏览器中就是window对象
}
```



**函数执行上下文**

调用函数时会创建一个函数执行上下文压入执行栈，并创建一个AO对象。函数执行上下文的VO指向AO，函数体中的代码执行完毕后函数执行上下文出栈并销毁，对应的AO对象不再被引用也会被回收掉

```js
EC = {
   VO                  //指向AO
   scope              //作用域，包含VO和函数的父级作用域，父级作用域在函数声明时确定
   this               //this在函数被调用时确定
}
```



**GO/AO对象** 变量对象、活动对象

全局和函数上下文在解析和执行时的行为是一致的。**解析时**会将全局/函数中顶级的 var和function声明的变量和函数添加到GO或AO中（函数还会把参数添加到AO中）。

**执行时**，调用到了任何数据，都会去执行上下文的作用域中查找，先到对应的GO/AO对象查找，找到了对其进行操作，如果没有则到函数的父级作用域对应的AO查找，再没有再向上查找直到全局执行上下文的作用域对应的GO。形成一条**作用域链**。



以代码为例

```js
var name = 123

function foo() {
  console.log("foo")
}
```

解析：

```js
GO = {
  // 一些内置的如Data、Math、console等可以直接访问的数据
  name: undefined,
  foo: {                //指向内存中新建的一个对象，包含该函数的父级作用域及函数体
    [[parent-scope]]  
    函数体
  }
}
// 所以var声明的变量在赋值前就可以访问到Undefiend而不是未定义，function函数在声明前就可以调用，称为提升
```

执行：

```js
GO = {
  name: 123    
}

//代码第一行调用到了name,先从作用域中的GO查找，找到了执行代码将其值置为123
```





第一题

```js
var n = 100;

function foo() {
  console.log("foo: " + n); 
}

function bar() {
  var n = 200;
  console.log("bar: " + n);
  foo();
}

bar();
console.log(n);

//打印 bar: 200  foo: 100   100
```



第二题

```js
var a = 100;

function foo() {
  console.log(a);
  return;
  var a = 100;
}

foo();

//打印 undefined
```





## JS的内存管理与垃圾回收



1. 代码在执行时会从磁盘读取到内存中，CPU执行内存中的代码，在执行过程中会产生很多的数据，这些数据保存在内存中，并在某一时刻释放掉这些内存空间。有些语言需要手动管理内存如C、C艹等，有些语言可以自动管理如 JAVA、JavaScript等



2. JavaScript会自动管理内存空间的分配和释放：



在JS代码执行时，基本数据类型的数据会在栈中分配一块空间保存值；引用数据类型会在堆中分配一块空间保存值，在栈中分配一块空间保存着该数据在堆中的地址。



在js引擎中内置有垃圾回收器（GC）负责定期进行垃圾回收，将不再参于代码运行的数据的内存空间释放掉。

常见的垃圾回收算法：

1. 引用计数：给每个值被引用的数量计数，当没有地方引用此值时，将其释放掉。缺点：两个数据相互引用，永远也不会被垃圾回收器释放掉。这时候就要手动释放空间，将两个值置为NULL
2. 标记清除：（常用）

![image-20210903165550561](https://gitee.com/li_zihang/typora-drawing-bed/raw/master/图片/image-20210903165550561.png)



4. 内存泄露：

不再用到的数据一直占据着内存空间，不能及时释放掉，就叫做内存泄漏（memory leak）



5. 哪些情况会导致内存泄漏： 



- **意外的全局变量：** 由于在非严格模式使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收直到程序结束。如

```js
function foo() {
  name = "admin"
}
```

- **被遗忘的计时器或回调函数：** 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中直到程序结束，而无法被回收。
- **脱离 DOM 的引用：** 在js中定义一个变量引用一个 DOM 元素，而后文档流解除对这个对象的引用，但变量还一直保留了对这个元素的引用，所以它也无法被回收。

```js
var refA = document.getElementById('refA');
document.body.removeChild(refA); 
console.log(refA, "refA");  

// <div id="refA"></div>  refA
```

- **闭包：** 不合理的使用闭包，从而导致某些变量一直被留在内存当中。



**意外的全局变量、被遗忘的计时器是不是也是闭包？**



5. 减少垃圾回收

虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。

- **对数组进行优化：** 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。
- **对**`object`**进行优化：** 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。
- **对函数进行优化：** 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。





## 闭包

1. 什么是闭包
2. 为什么自由变量不会被销毁
3. 为什么要使用闭包
4. 闭包可能造成内存泄漏的问题





1. 什么是闭包？



一个函数中如果调用了外层作用域的变量（此时称为自由变量），那么这个函数和自由变量就形成了一个闭包。自由变量直到这个函数被回收才会被回收。

```js
var name = "admin";
function foo() {
  console.log(name)
}
```

闭包的应用：通常是在一个函数A中嵌套定义并返回一个调用了函数A中数据的函数B，这样就能在函数A外部调用函数B访问函数A内的数据了。

```js
function bar() {
  var name = "admin";
  var age = 18
  
  function foo() {
    console.log(name)
  }
  
  return foo
}

const baz = bar()
baz()                   //admin
```



为什么 bar 函数执行完后，调用 foo 函数还会访问到 name 为 "admin" ，为什么 name 不会在 bar 函数执行完后销毁？

bar函数执行上下文指向的AO对象为：

```
Ao = {
  name: "admin",
  foo: {
    [[parent-scope]]    //foo函数父级作用域，即AO
    函数体
  }
}
```

由于bar函数将foo返回出去，即baz也指向了AO中foo指向的对象。所以bar函数执行完后，函数执行上下文销毁了，AO失去了bar函数执行上下文中VO的指向，但还有baz指向的对象引用着AO，所以AO不会被回收。所以在bar函数执行完之后还可以通过未销毁的AO访问name。

注意的是，函数foo中未调用age，即age不是自由变量。即使AO保存了下来，AO中的非自由变量如age也会被销毁。(v8引擎实现)

<img src="https://gitee.com/li_zihang/typora-drawing-bed/raw/master/图片/image-20210907162303892.png" alt="image-20210907162303892" style="zoom: 67%;" />

