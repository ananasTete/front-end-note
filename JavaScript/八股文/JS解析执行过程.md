# 执行上下文





### 什么是执行上下文？



用于解析执行JS代码的环境

执行上下文分为全局执行上下文和函数执行上下文。默认将全局执行上下文压入执行栈，执行代码。当执行到调用函数时，创建一个函数执行上下文，执行完函数执行上下文的代码后，函数执行上下文出栈销毁，继续执行全局上下文中的代码。

执行上下文的构成：

```
EC = {
  VO                  //变量对象
  scope-chain         //作用域链
  this                //this指向
}
```





### 执行上下文的生命周期



创建——执行——销毁

以代码为例：

```js
var name = "admin"

function foo(name) {
  console.log(name)
}

foo(name)
```

**运行代码，创建全局执行上下文**

- VO指向全局对象GO，在浏览器中为window对象，开始解析全局代码，初始化VO对象

  ```js
  GO = {
    //一些内置的可以直接访问的数据如String、Data、console等
    name: undefined
    foo: {
      [[parent-scope]]     //父级作用域
      函数体
    }
  }
  
  // 将顶级的var、function声明作为VO对象的属性
  ```

- 设置 scope-chain 为 VO + null

- 全局执行上下文中this指向window对象

**将全局执行上下文压入执行栈，执行代码**

- 调用name将其赋值为admin，在该执行上下文的 scope-chain中查找变量，首先到VO即GO中查找，找到则将GO中的name赋值为admin
- 调用foo函数，同理在GO中找到foo，调用函数时暂停执行全局上下文中的代码，创建函数执行上下文
> 因为顶级的var、function声明在执行代码前就添加到了VO中，所以代码中在定义数据前就可以访问到name为undefined、调用函数而不是报错未定义。这种现象称为提升。

**创建函数执行上下文、AO对象**

- 将VO指向新建的AO对象，开始解析函数中的代码，初始化VO对象

  ```js
  AO = {
    name: admin
  }
  
  // 将参数、顶级的var、function声明添加到VO中作为属性
  ```

- 设置scope-chain为 VO + [[parent-scope]]

- this指向调用该函数的对象

**将函数执行上下文压入执行栈，执行函数中的代码**

- 打印foo

**函数代码执行完毕，函数执行上下文出栈销毁，继续执行全局上下文中的代码**

**全局上下文中的代码执行完毕，出栈销毁，程序结束**



函数上下文销毁后，对应的AO对象失去了唯一的引用，也会被垃圾回收机制回收。





# 作用域



执行上下文与作用域的关系？





# 闭包

