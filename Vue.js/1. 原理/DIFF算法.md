## DIFF算法



li 元素通过v-for遍历下面的数组

array= [ a,b,c,d ]

然后将数组变成 array= [ a,b,f,c,d ]，在中间插入一个 f，数据变更时如何渲染才能效率更高一些？



真实DOM是由虚拟DOM渲染而成，虚拟DOM被销毁那真实DOM也应该被销毁。

数据发生变化时，会重新渲染一次依赖此数据的虚拟DOM。所以数组发生改变，会重新渲染所有的li对应的虚拟DOM。

不能直接将列表中的虚拟DOM全部销毁将新的虚拟DOM取而代之。这样的话真实DOM也会被销毁又根据新的虚拟DOM重建一次，如果只有部分数据发生改变会造成不必要的性能开销。而是另外创建新的虚拟DOM通过DIFF算法将新的虚拟DOM与旧的虚拟DOM进行对比，更新旧的虚拟DOM。

向数组中插入 f，获取列表的旧VNode数组，获取列表的新VNode数组，

没有key:

比较新旧VNode数组哪个长度更短，根据短的长度从头开始进遍历两个数组进行patch(更新)，在patch中，如果类型和数据相同没什么更新的；如果类型相同，数据不同或类型不同数据相同，将旧VNode的数据更新为新VNode的数据或将旧VNode的类型更新为新VNode的类型；如果类型数据都不同，则将旧VNode完全更新为新VNode。

如果旧VNode数组比新VNode数组长，则将旧VNode中多余的VNode销毁对应的真实节点也会被销毁；如果旧VNode数组比新VNode数组短，则旧VNode数组根据新VNode数组中多余的VNode与旧VNode数组中的 null进行patch，即在旧VNode数组中创建新的VNode并渲染成新的真实节点；

有key:（key相同则认为数据相同）

两个数组都从**头部**开始遍历，对应的节点进行判断，如果数据类型和KEY都相同，则对新旧vnode进行 patch(更新)，将旧VNode更新为新VNode，因为这里相同也没什么更新的，此VNode没有变化，旧Vnode对应的真实DOM不变，等到不同时退出此遍历；

（c 和 f不同）

两个数组都从**尾部**进行遍历，对应的节点进行判断。同上。

（b和 f不同）

两次遍历完成后如果旧VNode数组有多余的节点（没有被patch过的VNode）记录位置并根据位置销毁；新VNode数组有多余的节点（没有被patch过的VNode）记录位置与旧VNode数组中对应位置的 null进行patch，即在旧VNode数组中创建新的VNode并渲染成新的真实节点；

